<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Insect tree</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading tree...</div>
  </div>
  <div id="root"></div>

  <script type="module">
    import React from 'https://esm.sh/react@19';
    import { createRoot } from 'https://esm.sh/react-dom@19/client';
    import Taxonium from 'https://esm.sh/taxonium-component';

    // Import local modules
    import { createPlacementCountLegend, generateColorMapping } from './color-legend.js';
    import { createSequencesModal } from './sequences.js';

    const { createElement: h, useState, useEffect, useCallback } = React;

    // Create components with React
    const PlacementCountLegend = createPlacementCountLegend(React);
    const SequencesModal = createSequencesModal(React);

    // Promise-based delay helper
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function App() {
      const [sourceData, setSourceData] = useState(null);
      const [error, setError] = useState(null);
      const [query, setQuery] = useState({});
      const [maxPlacementCount, setMaxPlacementCount] = useState(0);
      const [colorByField, setColorByField] = useState('meta_placement_count');
      const [sequencesModalNode, setSequencesModalNode] = useState(null);
      const [lastViewedNode, setLastViewedNode] = useState(null);

      // Handler to update query state (used by Taxonium for view/selection state)
      const updateQuery = (newQuery) => {
        setQuery(prev => ({ ...prev, ...newQuery }));
        // Track color field changes from query
        if (newQuery.color !== undefined) {
          setColorByField(newQuery.color);
        }
      };

      // Handler for when node details are loaded - stores last viewed node for floating button
      const handleNodeDetailsLoaded = useCallback((nodeId, nodeDetails) => {
        if (nodeId === null || !nodeDetails) return;

        const nodeName = nodeDetails.meta_name || nodeDetails.name || nodeDetails.label || `Node ${nodeId}`;

        // Extract metadata fields (strip meta_ prefix)
        const metaFields = ['common_name', 'clade', 'subclass', 'order', 'superfamily', 'family',
                           'subfamily', 'genus', 'node_number', 'placement_count', 'top_sequences',
                           'other_sequences', 'ThumbnailURL'];
        const metadata = Object.fromEntries(
          metaFields.map(field => [field, nodeDetails[`meta_${field}`]])
        );

        setLastViewedNode({ id: nodeId, name: String(nodeName), metadata });
      }, []);

      // Workaround: Enable "Display points for internal nodes" after component loads
      useEffect(() => {
        if (!sourceData) return;

        let cancelled = false;

        const hideOverlay = async () => {
          const overlay = document.getElementById('loading-overlay');
          if (overlay) {
            overlay.classList.add('fade-out');
            await delay(300);
            overlay.remove();
          }
        };

        const enableCheckbox = (labelText) => {
          const label = Array.from(document.querySelectorAll('label'))
            .find(l => l.textContent.includes(labelText));
          const checkbox = label?.querySelector('input[type="checkbox"]');
          if (checkbox && !checkbox.checked) {
            checkbox.click();
            console.log('Enabled:', labelText);
          }
        };

        const findSettingsButton = () =>
          document.querySelector('button[aria-label="Settings"]')
          || document.querySelector('button svg[data-icon="cog"]')?.closest('button')
          || Array.from(document.querySelectorAll('button')).find(btn =>
              btn.querySelector('svg') && btn.textContent === '');

        const closeModal = () => {
          const closeButton = document.querySelector('[aria-label="Close"]')
            || document.querySelector('button svg[data-icon="times"]')?.closest('button')
            || document.querySelector('[role="dialog"] button');
          if (closeButton) {
            closeButton.click();
          } else {
            document.querySelector('[role="dialog"]')?.parentElement?.click();
          }
        };

        const configureSettings = async () => {
          // Wait for settings button to appear (max 10 seconds)
          let settingsButton;
          for (let i = 0; i < 10 && !cancelled; i++) {
            settingsButton = findSettingsButton();
            if (settingsButton) break;
            await delay(1000);
          }

          if (cancelled || !settingsButton) {
            await hideOverlay();
            return;
          }

          settingsButton.click();
          await delay(300);

          enableCheckbox('Display points for internal nodes');
          enableCheckbox('Display labels for internal nodes if present');

          await delay(100);
          closeModal();
          await delay(100);
          await hideOverlay();
        };

        configureSettings();

        return () => { cancelled = true; };
      }, [sourceData]);

      useEffect(() => {
        const loadData = async () => {
          try {
            // Fetch the Newick tree data and metadata in parallel
            const [nwkResponse, metadataResponse] = await Promise.all([
              fetch('tree.nwk'),
              fetch('metadata.tsv')
            ]);

            if (!nwkResponse.ok) {
              throw new Error(`Failed to load tree.nwk: ${nwkResponse.statusText}`);
            }
            const nwk = await nwkResponse.text();

            // Load metadata if available
            let metadata = null;
            let colorMapping = {};
            if (metadataResponse.ok) {
              const metadataText = await metadataResponse.text();

              // Parse metadata and remove unwanted columns
              const lines = metadataText.trim().split('\n');
              const header = lines[0].split('\t');

              // Find columns to remove (in reverse order to preserve indices)
              // Note: keep other_sequences for the sequences modal, just don't display in Taxonium
              const columnsToRemove = ['placement_bin']
                .map(col => header.indexOf(col))
                .filter(idx => idx !== -1)
                .sort((a, b) => b - a);  // Sort descending to remove from end first

              // Filter out unwanted columns from metadata
              let filteredMetadataText = metadataText;
              if (columnsToRemove.length > 0) {
                const filteredLines = lines.map(line => {
                  const cols = line.split('\t');
                  columnsToRemove.forEach(idx => cols.splice(idx, 1));
                  return cols.join('\t');
                });
                filteredMetadataText = filteredLines.join('\n');
              }

              metadata = {
                status: "loaded",
                filename: "metadata.tsv",
                filetype: "meta_tsv",
                data: filteredMetadataText,
                taxonColumn: "name",
              };

              // Find the maximum placement_count value for color scaling
              const countIndex = header.indexOf('placement_count');
              let maxValue = 0;

              lines.slice(1).forEach(line => {
                const cols = line.split('\t');
                if (countIndex !== -1 && cols[countIndex]) {
                  maxValue = Math.max(maxValue, Number(cols[countIndex]) || 0);
                }
              });

              // Generate colors for all integers from 0 to maxValue using log scale
              colorMapping = generateColorMapping(maxValue);
              console.log('Generated colorMapping for values 0 to', maxValue);
              setMaxPlacementCount(maxValue);
            }

            // Construct the sourceData object with metadata
            const newSourceData = {
              status: "loaded",
              filename: "tree.nwk",
              filetype: "nwk",
              data: nwk,
              metadata: metadata,
              colorMapping: colorMapping,
              useDistances: false,  // Align tips (cladogram mode)
            };

            setSourceData(newSourceData);

          } catch (err) {
            console.error("Error loading Taxonium data:", err);
            setError(err.message);
          }
        };

        loadData();
      }, []);

      // Monitor DOM for color field changes from Taxonium's dropdown
      useEffect(() => {
        if (!sourceData) return;

        const checkColorField = () => {
          for (const select of document.querySelectorAll('select')) {
            const hasPlacementCount = Array.from(select.options).some(opt =>
              opt.value?.includes('placement_count') || opt.text?.includes('placement_count')
            );
            if (hasPlacementCount) {
              setColorByField(select.value?.includes('placement_count') ? 'meta_placement_count' : select.value || '');
              break;
            }
          }
        };

        const interval = setInterval(checkColorField, 1000);
        checkColorField();
        return () => clearInterval(interval);
      }, [sourceData]);

      if (error) {
        return h('div', null, `Error: ${error}`);
      }

      if (!sourceData) {
        return h('div', null, 'Loading Taxonium data...');
      }

      const isPlacementCountColor = colorByField === 'meta_placement_count' || colorByField?.includes('placement_count');

      return h('div', { className: 'taxonium taxonium-wrapper' },
        h(Taxonium, {
          sourceData,
          configDict: {
            defaultColorByField: "meta_placement_count",
            colorMapping: sourceData.colorMapping || {},
            keys_to_display: [
              "meta_common_name", "meta_clade", "meta_subclass", "meta_order", "meta_superfamily",
              "meta_family", "meta_subfamily", "meta_genus", "meta_node_number",
              "meta_placement_count", "meta_top_sequences"
            ]
          },
          query,
          updateQuery,
          onNodeDetailsLoaded: handleNodeDetailsLoaded,
        }),
        sequencesModalNode && h(SequencesModal, {
          node: sequencesModalNode,
          onClose: () => setSequencesModalNode(null),
        }),
        lastViewedNode?.metadata?.top_sequences && h('button', {
          className: 'view-sequences-floating-btn',
          onClick: () => setSequencesModalNode(lastViewedNode),
          title: `View all barcodes for ${lastViewedNode.name}`
        },
          h('span', null, 'View all barcodes:'),
          h('span', { className: 'node-name' }, lastViewedNode.name)
        ),
        h(PlacementCountLegend, { maxValue: maxPlacementCount, visible: isPlacementCountColor })
      );
    }

    const container = document.getElementById('root');
    const root = createRoot(container);
    root.render(h(App));
  </script>
</body>
</html>
